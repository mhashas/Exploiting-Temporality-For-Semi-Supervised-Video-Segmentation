import os
import torch
from torchvision.utils import make_grid
from tensorboardX import SummaryWriter
import glob
from util.general_functions import tensor2im, tensor2submit_image
import numpy as np
from PIL import Image

class TensorboardSummary(object):
    def __init__(self, args):
        self.args = args
        self.experiment_dir = self.generate_directory(args)
        self.writer = SummaryWriter(log_dir=os.path.join(self.experiment_dir))

    def generate_directory(self, args):
        checkname = 'debug-' if args.debug else ''
        checkname += args.model

        if 'deeplab' in args.model:
            checkname += '-pretrained' if args.pretrained_resnet else ''
            checkname += '-os:' + str(args.output_stride)

        if 'unet' in args.model:
            checkname += '-num_downs:' + str(args.num_downs) + '-ngf:' + str(args.ngf) + '-down_type:' + str(args.down_type)

        checkname += '-mode:' + args.mode

        if 'sequence' in args.mode:
            checkname += '-seq_model:' + args.sequence_model

            if args.sequence_stacked_models > 1:
                checkname += '-stacked:' + str(args.sequence_stacked_models)

            if args.sequence_model == 'lstm':
                if args.lstm_bidirectional:
                    checkname += '-bidirectional:True'

                if args.lstm_initial_state != '0':
                    checkname += '-init_state:' + args.lstm_initial_state

            if 'tcn' in args.sequence_model:
                checkname += '-num_levels_tcn:' + str(args.num_levels_tcn)
                checkname += '-tcn_kernel_size:' + str(args.tcn_kernel_size)

        checkname += '-init_type:' + args.init_type
        checkname += '-optim:' + args.optim + '-lr:' + str(args.lr)

        if args.clip > 0:
            checkname += '-clipping:' + str(args.clip)

        if args.reconstruct:
            checkname += '-reconstruct:' + args.reconstruct_loss_type + '-' + str(args.reconstruct_loss_coeff)
            checkname += '-rec_remove_skip:1' if args.reconstruct_remove_skip else ''

        checkname += '-blanked' if args.blank else ''
        checkname += '-seg_removed_skip:1' if args.remove_skip else ''
        checkname += '-resize:' + ','.join([str(x) for x in list(args.resize)])

        if args.loss_type == 'focal':
            checkname += '-focal'

        if args.use_class_weights:
            checkname += '-weighted'

        if 'sequence' in args.mode:
            checkname += '-td:' + str(args.time_dilation)

        checkname += '-epochs:' + str(args.epochs)
        checkname += '-trainval:1' if args.trainval else ''

        directory = os.path.join(args.results_dir, args.dataset, args.model, checkname)

        runs = sorted(glob.glob(os.path.join(directory, 'experiment_*')))
        run_id = int(runs[-1].split('_')[-1]) + 1 if runs else 0
        experiment_dir = os.path.join(directory, 'experiment_{}'.format(str(run_id)))

        if not os.path.exists(experiment_dir):
            os.makedirs(experiment_dir)

        return experiment_dir

    def add_scalar(self, tag, value, step):
        self.writer.add_scalar(tag, value, step)

    def add_results(self, epoch, mIOU, acc, acc_class, fwavacc, test_loss, split="train"):
        self.writer.add_scalar(split + '/total_loss_epoch', test_loss, epoch)
        self.writer.add_scalar(split + '/mIoU', mIOU, epoch)
        self.writer.add_scalar(split + '/Acc', acc, epoch)
        self.writer.add_scalar(split + '/Acc_class', acc_class, epoch)
        self.writer.add_scalar(split + '/Forward_acc', fwavacc, epoch)

    def visualize_image(self, epoch, image, target, output=None, reconstructed_image=None, reconstruction_target=None, split="train"):
        if output is not None:
            output = torch.argmax(output, dim=1)
            output[(target == 255)] = 255

        images = []
        outputs = []
        targets = []
        reconstructed_images = []
        reconstruction_targets = []

        number_of_images = min(5, image.size(0))

        for i in range(number_of_images):
            if output is not None:
                outputs.append(tensor2im(output[i]))
                targets.append(tensor2im(target[i]))

            if not self.args.blank:
                images.append(tensor2im(image[i]))
            else:
                images.append(image[i])

            if reconstructed_image is not None:
                reconstructed_images.append(tensor2im(reconstructed_image[i]))
                reconstruction_targets.append(tensor2im(reconstruction_target[i]))

        grid_image = make_grid(images)
        self.writer.add_image(split + '/ZZ Image', grid_image, epoch)

        if output is not None:
            grid_image = make_grid(outputs)
            self.writer.add_image(split + '/Predicted label', grid_image, epoch)

            grid_image = make_grid(targets)
            self.writer.add_image(split + '/Groundtruth label', grid_image, epoch)

        if reconstructed_image is not None:
            grid_image = make_grid(reconstructed_images)
            self.writer.add_image(split + '/ZZ Recon Image', grid_image, epoch)

            grid_image = make_grid(reconstruction_targets)
            self.writer.add_image(split + '/ZZ Recon Target', grid_image, epoch)

    def save_visualization_images(self, outputs, targets, paths=''):
        outputs_save_dir = 'images/' + self.experiment_dir.replace('./', '')

        if not os.path.isdir(outputs_save_dir):
            os.makedirs(outputs_save_dir)

        targets_save_dir = os.path.join('images', 'targets')
        save_targets = False

        if not os.path.isdir(targets_save_dir):
            save_targets = True
            os.makedirs(targets_save_dir)

        if len(paths) == 0:
            outputs[(targets == 255)] = 255

        for i in range(outputs.size(0)):
            if self.args.submit_format:
                output = tensor2submit_image(outputs[i])
            else:
                output = tensor2im(outputs[i], return_tensor=False)

            if len(paths) == 0:
                name = str(i) + '.png'
            else:
                name = paths[i]

            if not self.args.submit_format:
                output = Image.fromarray(output.astype('uint8'))

            output.save(outputs_save_dir + '/' + name)

            if save_targets:
                target = tensor2im(targets[i], return_tensor=False)
                target = Image.fromarray(target.astype('uint8'))
                target.save(targets_save_dir + '/' + name)

    def save_network(self, model):
        path = self.args.save_dir + '/' + self.experiment_dir.replace('./', '')

        if not os.path.isdir(path):
            os.makedirs(path)

        torch.save(model.state_dict(), path + '/' + 'network.pth')
